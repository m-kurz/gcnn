#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# SPDX-License-Identifier: MIT
#
# Copyright (c) 2024, Marius Kurz
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import time
import numpy as np
import tensorflow as tf

from gcnn.layers import GraphConv, GraphReadout
from gcnn.utils import GridGraph


def build_model(
        p: int,
        sparse: bool,
        n_message_passing=3,
        latent_dim=128,
        initializer='he_uniform'
    ):
    """Build a simple GCN model with Encoder and Decoder."""
    # Get graph adjacency matrix
    A = GridGraph.get_adjacency_matrix((p,p,p))
    # Simple GCN with Encoder and Decoder
    inputs = tf.keras.Input(shape=(np.power(p,3), 3))
    # Encoder
    x = tf.keras.layers.Dense(        16, activation='relu', kernel_initializer='he_uniform')(inputs)
    x = tf.keras.layers.Dense(latent_dim, activation='relu', kernel_initializer='he_uniform')(x)
    # n rounds of GCN-style message passing
    for _ in range(n_message_passing):
        x = GraphConv(latent_dim, A, kernel_initializer=initializer, sparse_op=sparse)(x)
        x = tf.keras.layers.Activation('relu')(x)
    # Readout layer
    outputs = GraphReadout(reduction_op='mean', reduction_dim=-2)(x)
    return tf.keras.Model(inputs=inputs, outputs=outputs, name='GCN')


def compute_A_sparsity(p: int):
    """Compute the sparsity of the adjacency matrix version."""
    A = GridGraph.get_adjacency_matrix((p,p,p))
    A_density = ( np.count_nonzero(A) / float(A.size) )
    print(f'A     for p={p:1d}:  Density: {A_density:.4f}  Sparsity: {1.-A_density:.4f}')
    A_hat = GraphConv._compute_A_hat(A, sparse=False)
    A_hat = A_hat.numpy()
    A_hat_density = ( np.count_nonzero(A_hat) / float(A_hat.size) )
    print(f'A_hat for p={p:1d}:  Density: {A_hat_density:.4f}  Sparsity: {1.-A_hat_density:.4f}')


def compare_dense_sparse_performance(
        p: int,
        batch_size=128,
        input_var=3,
        num_tries=100
    ):
    """Compare the performance of the dense and sparse GCN layers."""
    data = np.random.rand(batch_size, np.power(p,3), input_var)
    # Dense
    model_dense = build_model(p, sparse=False)
    mytime = time.time()
    for _ in range(num_tries):
        _ = model_dense(data)
    print(f'DENSE  Time: {(time.time()-mytime)/num_tries:.4e} s')
    # Sparse
    model_sparse = build_model(p, sparse=True)
    mytime = time.time()
    for _ in range(num_tries):
        _ = model_sparse(data)
    print(f'SPARSE  Time: {(time.time()-mytime)/num_tries:.4e} s')


def check_dense_sparse_correctness(
        p: int,
        batch_size=128,
        input_var=3,
        num_tries=100
    ):
    """Check whether the dense and sparse GCN layers yield the same results."""
    model_dense = build_model(p, sparse=False, initializer='Identity')
    model_sparse = build_model(p, sparse=True, initializer='Identity')
    for i in range(num_tries):
        data = np.random.rand(batch_size, np.power(p,3), input_var)
        res_dense = model_dense(data)
        res_sparse = model_sparse(data)
        assert np.allclose(res_sparse, res_dense)


def check_symmetries_octahedral(
        p:int,
        model: tf.keras.Model,
        batch_size=16,
        input_var=3
    ):
    """Check whether model obeys the symmetries of an octahedral group.

    The octahedral group O is a finite subgroup of the SO(3) group, which
    entails all rotations in R^3 that leave the origin fixed. O entails all
    rotations by 90Â° including reflections. There are a total of 48 elements
    in O, which can be generated by the 6 permutations of the principal axes
    and the 2^3=8 reflections, two different reflections for each axis. 24 of
    these elements preserve the orientation of the axes, while the other 24
    elements invert the orientation of the axes.
    """
    data = [np.random.rand(batch_size, p, p, p, input_var).astype(np.float32)]
    # Add the 5 permutations
    data.append(data[0].transpose(0,1,3,2,4))
    data.append(data[0].transpose(0,2,1,3,4))
    data.append(data[0].transpose(0,2,3,1,4))
    data.append(data[0].transpose(0,3,1,2,4))
    data.append(data[0].transpose(0,3,2,1,4))
    # Reflections along axes for each of the 6 permutations
    for i in range(6):
        data.append(np.flip(data[i], axis=(1,    )))
        data.append(np.flip(data[i], axis=(1,2   )))
        data.append(np.flip(data[i], axis=(1,2,3 )))
        data.append(np.flip(data[i], axis=(  2,  )))
        data.append(np.flip(data[i], axis=(  2,3 )))
        data.append(np.flip(data[i], axis=(    3,)))
    # Flatten
    data_reshape = []
    for d in data:
        data_reshape.append(d.reshape(batch_size, np.power(p,3), input_var))
    # Assert transformed results do not change
    res_ref = model(data_reshape[0])
    for d in data_reshape:
        res = model(d)
        assert np.allclose(res, res_ref, rtol=1.e-5, atol=1.e-8,)

def main():
    NUM_TRIES = 10
    for p in range(1,9):
        # Get sparsity of adjacency matrix
        compute_A_sparsity(p)

        # Check correctness of dense and sparse layers
        check_dense_sparse_correctness(p)

        # Compare performance of dense and sparse layers
        compare_dense_sparse_performance(p, num_tries=NUM_TRIES)

        # Check that GNN obeys the symmetries
        model_sparse = build_model(p, sparse=True)
        check_symmetries_octahedral(p, model_sparse)
        model_dense = build_model(p, sparse=False)
        check_symmetries_octahedral(p, model_dense)

if __name__ == '__main__':
    main()
